use crate::base::get_error_string;
use crate::helpers::u32_into_u16_unchecked;
use core_foundation::base::OSStatus;
use num_enum::{IntoPrimitive, TryFromPrimitive};
use strum::{AsRefStr, IntoStaticStr, VariantArray};
use sys::system_configuration::{
    kSCStatusAccessError, kSCStatusConnectionIgnore, kSCStatusConnectionNoService, kSCStatusFailed,
    kSCStatusInvalidArgument, kSCStatusKeyExists, kSCStatusLocked, kSCStatusMaxLink,
    kSCStatusNeedLock, kSCStatusNoConfigFile, kSCStatusNoKey, kSCStatusNoLink,
    kSCStatusNoPrefsSession, kSCStatusNoStoreServer, kSCStatusNoStoreSession,
    kSCStatusNotifierActive, kSCStatusOK, kSCStatusPrefsBusy, kSCStatusReachabilityUnknown,
    kSCStatusStale,
};

/// This is a thin wrapper around [`SCStatusKind`] which allows for potentially ***unknown types***
/// of status or error codes.
///
/// Other than that, there is no difference so refer to [`SCStatusKind`] for more information.
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct SCStatus(Result<SCStatusKind, OSStatus>);

impl SCStatus {
    /// Creates a new [`SCStatus`] from a status code.
    pub fn from_code(code: OSStatus) -> Self {
        Self(SCStatusKind::try_from_code(code))
    }

    /// Creates a new [`SCStatus`] from a known [`SCStatusKind`].
    pub fn from_known_status(status: SCStatusKind) -> Self {
        Self(Ok(status))
    }

    /// Returns the code of the current status.
    pub fn code(&self) -> OSStatus {
        self.0.as_ref().map_or_else(|s| *s, SCStatusKind::code)
    }

    /// Returns a string describing the current status.
    pub fn message(&self) -> String {
        self.0
            .as_ref()
            .map_or_else(|s| get_error_string(*s), SCStatusKind::message)
    }

    /// Attempts to return a known [`SCStatusKind`] that this status represents, or falls back to
    /// [`OSStatus`] if not known
    pub fn kind(&self) -> Result<SCStatusKind, OSStatus> {
        self.0
    }
}

// trait implementations for status type
mod status_trait_impls {
    use crate::status_temp::{SCStatus, SCStatusKind};
    use core_foundation::base::OSStatus;
    use num_enum::TryFromPrimitive;
    use std::{error, fmt};

    impl fmt::Debug for SCStatus {
        #[cold]
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let variant_name = self.0.as_ref().map_or("Unknown", |s| s.as_ref());
            fmt.debug_struct(&*format!("SCStatus::{variant_name}"))
                .field("code", &self.code())
                .field("message", &self.message())
                .finish()
        }
    }
    impl fmt::Display for SCStatus {
        #[cold]
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(fmt, "{}", self.message())
        }
    }
    impl From<SCStatus> for OSStatus {
        fn from(value: SCStatusKind) -> Self {
            value.code()
        }
    }
    impl From<OSStatus> for SCStatus {
        fn from(value: OSStatus) -> Self {
            Self::from_code(value)
        }
    }
    impl From<SCStatusKind> for SCStatus {
        fn from(value: SCStatusKind) -> Self {
            Self::from_known_status(value)
        }
    }
    impl TryFrom<SCStatus> for SCStatusKind {
        type Error = OSStatus;
        fn try_from(value: SCStatus) -> Result<Self, Self::Error> {
            value.kind()
        }
    }
    impl error::Error for SCStatus {}
}

/// A ***known type*** of status or error code generated by the most recent System Configuration
/// function call.
///
/// See [Apple's Documentation] for details.
///
/// [Apple Documentation]: https://developer.apple.com/documentation/systemconfiguration/1518026-status-and-error-codes?language=objc
#[derive(
    Copy,
    Clone,
    Ord,
    PartialOrd,
    Eq,
    PartialEq,
    Hash,
    IntoPrimitive,
    TryFromPrimitive,
    VariantArray,
    IntoStaticStr,
    AsRefStr,
)]
#[repr(u16)]
pub enum SCStatusKind {
    /// The call was successful.
    OK = u32_into_u16_unchecked(kSCStatusOK),
    /// A nonspecific failure occurred.
    Failed = u32_into_u16_unchecked(kSCStatusFailed),
    /// An invalid argument was specified.
    InvalidArgument = u32_into_u16_unchecked(kSCStatusInvalidArgument),
    /// Permission is denied; you must be root to obtain a lock. As a result, the function could not
    /// create or access preferences.
    AccessError = u32_into_u16_unchecked(kSCStatusAccessError),
    /// No such key.
    NoKey = u32_into_u16_unchecked(kSCStatusNoKey),
    /// Data associated with key already defined.
    KeyExists = u32_into_u16_unchecked(kSCStatusKeyExists),
    /// A lock is already held.
    Locked = u32_into_u16_unchecked(kSCStatusLocked),
    /// A lock is required for this operation.
    NeedLock = u32_into_u16_unchecked(kSCStatusNeedLock),
    /// The configuration daemon session is not active.
    NoStoreSession = u32_into_u16_unchecked(kSCStatusNoStoreSession),
    /// The configuration daemon is not available or no longer available.
    NoStoreServer = u32_into_u16_unchecked(kSCStatusNoStoreServer),
    /// Notifier is currently active.
    NotifierActive = u32_into_u16_unchecked(kSCStatusNotifierActive),
    /// The preferences session is not active.
    NoPrefsSession = u32_into_u16_unchecked(kSCStatusNoPrefsSession),
    /// A preferences update is currently in progress.
    PrefsBusy = u32_into_u16_unchecked(kSCStatusPrefsBusy),
    /// The configuration file cannot be found.
    NoConfigFile = u32_into_u16_unchecked(kSCStatusNoConfigFile),
    /// No such link exists.
    NoLink = u32_into_u16_unchecked(kSCStatusNoLink),
    /// A write was attempted on a stale version of the object.
    Stale = u32_into_u16_unchecked(kSCStatusStale),
    /// The maximum link count is exceeded.
    MaxLink = u32_into_u16_unchecked(kSCStatusMaxLink),
    /// Network reachability cannot be determined.
    ReachabilityUnknown = u32_into_u16_unchecked(kSCStatusReachabilityUnknown),
    /// Network service for the connection is not available.
    ConnectionNoService = u32_into_u16_unchecked(kSCStatusConnectionNoService),
    /// Network connection information is not available at this time.
    ConnectionIgnore = u32_into_u16_unchecked(kSCStatusConnectionIgnore),
}

impl SCStatusKind {
    /// Tries to create a new [`SCStatusKind`] from a status code. The code must correspond to one
    /// of the ***known*** status types.
    pub fn try_from_code(code: OSStatus) -> Result<Self, OSStatus> {
        let code_u16: u16 = code.try_into().map_err(|_| code)?;
        code_u16.try_into().map_err(|_| code)
    }

    /// Returns the code of the current status.
    pub fn code(&self) -> OSStatus {
        Into::<u16>::into(*self).into()
    }

    /// Returns a string describing the current status.
    pub fn message(&self) -> String {
        get_error_string(self.code())
    }
}

// trait implementations for status type
mod status_kind_trait_impls {
    use crate::status_temp::SCStatusKind;
    use std::{error, fmt};
    use sys::core_foundation_sys::base::OSStatus;

    impl fmt::Debug for SCStatusKind {
        #[cold]
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let variant_name: &str = self.as_ref();
            fmt.debug_struct(&*format!("SCStatusKind::{variant_name}"))
                .field("code", &self.code())
                .field("message", &self.message())
                .finish()
        }
    }
    impl fmt::Display for SCStatusKind {
        #[cold]
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(fmt, "{}", self.message())
        }
    }
    impl From<SCStatusKind> for OSStatus {
        fn from(value: SCStatusKind) -> Self {
            value.code()
        }
    }
    impl TryFrom<OSStatus> for SCStatusKind {
        type Error = OSStatus;

        fn try_from(value: OSStatus) -> Result<Self, Self::Error> {
            Self::try_from_code(value)
        }
    }
    impl error::Error for SCStatusKind {}
}
